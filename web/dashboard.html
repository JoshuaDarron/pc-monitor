<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PC Performance Monitor</title>
    <style>
        :root {
            --bg-primary: #f5f3ef;
            --bg-gradient: linear-gradient(135deg, #ffffff 0%, #f5f3ef 50%, #ede9e3 100%);
            --bg-card: rgba(0, 0, 0, 0.04);
            --border-card: rgba(0, 0, 0, 0.1);
            --border-card-hover: rgba(0, 0, 0, 0.2);
            --border-subtle: rgba(0, 0, 0, 0.06);
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --bar-bg: rgba(0, 0, 0, 0.08);
            --scrollbar-thumb: rgba(0, 0, 0, 0.15);
            --scrollbar-thumb-hover: rgba(0, 0, 0, 0.25);
            --scrollbar-track: #f5f3ef;
            --gauge-bg: rgba(0, 0, 0, 0.04);
            --error-bg: rgba(244, 67, 54, 0.1);
        }

        body.dark-theme {
            --bg-primary: #1a1a1a;
            --bg-gradient: linear-gradient(135deg, #121212 0%, #1a1a1a 50%, #222222 100%);
            --bg-card: rgba(255, 255, 255, 0.07);
            --border-card: rgba(255, 255, 255, 0.12);
            --border-card-hover: rgba(255, 255, 255, 0.25);
            --border-subtle: rgba(255, 255, 255, 0.05);
            --text-primary: #e0e0e0;
            --text-secondary: #999999;
            --bar-bg: rgba(255, 255, 255, 0.1);
            --scrollbar-thumb: rgba(255, 255, 255, 0.15);
            --scrollbar-thumb-hover: rgba(255, 255, 255, 0.25);
            --scrollbar-track: #1a1a1a;
            --gauge-bg: rgba(255, 255, 255, 0.05);
            --error-bg: rgba(244, 67, 54, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-gradient);
            color: var(--text-primary);
            height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) transparent;
        }

        ::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }

        html {
            background: var(--bg-primary);
            overflow: hidden;
            height: 100%;
        }

        .drag-region {
            height: 36px;
            -webkit-app-region: drag;
        }

        .dashboard {
            padding: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-card);
            border-radius: 16px;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            display: none;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .card:hover {
            border-color: var(--border-card-hover);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-subtle);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .metric-value {
            font-weight: 600;
            font-size: 1rem;
        }

        .metric-bar {
            width: 100%;
            height: 8px;
            background: var(--bar-bg);
            border-radius: 4px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .metric-fill {
            height: 100%;
            border-radius: 4px;
        }

        .gpu-fill { background: linear-gradient(90deg, #ff6b6b, #ff8e53); }
        .cpu-fill { background: linear-gradient(90deg, #4ecdc4, #44a08d); }
        .ram-fill { background: linear-gradient(90deg, #a8edea, #fed6e3); }
        .storage-fill { background: linear-gradient(90deg, #ffeaa7, #fab1a0); }
        .temp-fill { background: linear-gradient(90deg, #74b9ff, #0984e3); }


        .performance-indicator {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .excellent { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .good { background: rgba(255, 235, 59, 0.2); color: #ffeb3b; }
        .fair { background: rgba(255, 152, 0, 0.2); color: #ff9800; }
        .poor { background: rgba(244, 67, 54, 0.2); color: #f44336; }

        .last-update {
            color: var(--text-secondary);
            font-size: 0.8rem;
            padding: 0 2rem;
            margin-bottom: -0.5rem;
        }

        .error {
            background: var(--error-bg);
            color: #f44336;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem;
            text-align: center;
        }

        /* Half-circle temperature gauge */
        .gauge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .half-gauge-svg {
            width: 140px;
            height: 85px;
            overflow: visible;
        }

        .half-gauge-bg {
            fill: none;
            stroke: var(--bar-bg);
            stroke-width: 10;
            stroke-linecap: round;
        }

        .half-gauge-fill {
            fill: none;
            stroke-width: 10;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease, stroke 0.5s ease;
        }

        .gauge-value-text {
            font-size: 1.3rem;
            font-weight: 700;
            fill: var(--text-primary);
            text-anchor: middle;
        }

        .gauge-label-text {
            font-size: 0.7rem;
            fill: var(--text-secondary);
            text-anchor: middle;
        }

        /* Utilization history area chart */
        .chart-container {
            position: relative;
            width: 100%;
            height: 100px;
            background: var(--gauge-bg);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .chart-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .chart-label {
            position: absolute;
            top: 6px;
            left: 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            pointer-events: none;
        }

        .chart-value {
            position: absolute;
            top: 4px;
            right: 10px;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            pointer-events: none;
        }

        /* Circular clock speed gauge */
        .clock-gauge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .clock-gauge-svg {
            width: 120px;
            height: 120px;
            overflow: visible;
        }

        .clock-gauge-bg {
            fill: none;
            stroke: var(--bar-bg);
            stroke-width: 8;
            stroke-linecap: round;
        }

        .clock-gauge-fill {
            fill: none;
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .clock-value-text {
            font-size: 1.1rem;
            font-weight: 700;
            fill: var(--text-primary);
            text-anchor: middle;
        }

        .clock-unit-text {
            font-size: 0.65rem;
            fill: var(--text-secondary);
            text-anchor: middle;
        }

        .clock-label-text {
            font-size: 0.7rem;
            fill: var(--text-secondary);
            text-anchor: middle;
        }

        /* Gauge row — side-by-side gauge pairs */
        .gauge-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid var(--border-subtle);
        }

        @media (max-width: 900px) {
            .dashboard {
                grid-template-columns: 1fr;
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="drag-region"></div>

    <div class="last-update" id="lastUpdate">
        Connecting to monitoring service...
    </div>

    <div class="dashboard" id="dashboard">
        <div class="error">Loading system metrics...</div>
    </div>

    <script src="../renderer.js"></script>
    <script>
        function applyTheme(isDark) {
            document.body.classList.toggle('dark-theme', isDark);
        }
        if (window.electronAPI) {
            applyTheme(window.electronAPI.isDarkTheme);
            window.electronAPI.onThemeChange(applyTheme);
        } else {
            applyTheme(window.matchMedia('(prefers-color-scheme: dark)').matches);
            window.matchMedia('(prefers-color-scheme: dark)')
                .addEventListener('change', e => applyTheme(e.matches));
        }

        let isConnected = true;
        let isInitialized = false;

        // History buffers for area charts (60 entries = 1 minute at 1s polling)
        const utilizationHistory = { gpu: [], cpu: [], ram: [] };
        const storageHistory = { read: [], write: [] };
        const powerHistory = [];

        // Clock speed max tracker with sensible defaults, auto-expands
        const clockMaxTracker = { gpu: 2500, cpu: 5500 };

        // Auto-scaling max trackers for non-percentage charts
        const chartMaxTracker = { storageRead: 100, storageWrite: 100, power: 200 };

        // Chart gradient color sets
        const chartColors = {
            gpu: { line: 'rgba(255, 107, 107, 0.9)', top: 'rgba(255, 107, 107, 0.5)', bottom: 'rgba(255, 107, 107, 0.02)' },
            cpu: { line: 'rgba(78, 205, 196, 0.9)', top: 'rgba(78, 205, 196, 0.5)', bottom: 'rgba(78, 205, 196, 0.02)' },
            ram: { line: 'rgba(168, 237, 234, 0.9)', top: 'rgba(168, 237, 234, 0.5)', bottom: 'rgba(168, 237, 234, 0.02)' },
            storageRead: { line: 'rgba(255, 234, 167, 0.9)', top: 'rgba(255, 234, 167, 0.5)', bottom: 'rgba(255, 234, 167, 0.02)' },
            storageWrite: { line: 'rgba(250, 177, 160, 0.9)', top: 'rgba(250, 177, 160, 0.5)', bottom: 'rgba(250, 177, 160, 0.02)' },
            power: { line: 'rgba(116, 185, 255, 0.9)', top: 'rgba(116, 185, 255, 0.5)', bottom: 'rgba(116, 185, 255, 0.02)' }
        };

        // Canvas context cache
        const canvasContextCache = new Map();

        function pushHistory(arr, value) {
            arr.push(value);
            if (arr.length > 60) arr.shift();
        }

        function getPerformanceClass(value, thresholds) {
            if (value >= thresholds.excellent) return 'excellent';
            if (value >= thresholds.good) return 'good';
            if (value >= thresholds.fair) return 'fair';
            return 'poor';
        }

        function formatBytes(bytes) {
            if (bytes >= 1024) {
                return (bytes / 1024).toFixed(1) + ' GB';
            }
            return bytes + ' MB';
        }

        // Element reference cache — avoids repeated getElementById calls
        const elementCache = new Map();

        function getCachedElement(id) {
            let el = elementCache.get(id);
            if (!el) {
                el = document.getElementById(id);
                if (el) elementCache.set(id, el);
            }
            return el;
        }

        function updateElement(id, value) {
            const element = getCachedElement(id);
            if (element && element.textContent !== value) {
                element.textContent = value;
            }
        }

        function updateBar(id, percentage) {
            const element = getCachedElement(id);
            if (element) {
                element.style.width = percentage + '%';
            }
        }

        function updatePerformanceIndicator(id, className, text) {
            const element = getCachedElement(id);
            if (element) {
                element.className = 'performance-indicator ' + className;
                element.textContent = text;
            }
        }

        // --- Half-circle temperature gauge ---
        const HALF_GAUGE_ARC_LENGTH = 172.79;

        function updateHalfGauge(fillId, textId, tempC, min, max, statusId) {
            if (min === undefined) min = 30;
            if (max === undefined) max = 100;
            const fill = getCachedElement(fillId);
            const text = getCachedElement(textId);
            if (!fill || !text) return;

            const fraction = Math.max(0, Math.min(1, (tempC - min) / (max - min)));
            const offset = HALF_GAUGE_ARC_LENGTH * (1 - fraction);
            fill.style.strokeDashoffset = offset;

            // Color zones
            let color, label;
            if (tempC < 50) { color = '#4ecdc4'; label = 'Cool'; }
            else if (tempC < 70) { color = '#00ff88'; label = 'Optimal'; }
            else if (tempC < 85) { color = '#ffeb3b'; label = 'Warm'; }
            else { color = '#f44336'; label = 'Hot'; }
            fill.style.stroke = color;

            text.textContent = tempC + '°C';

            if (statusId) {
                const statusEl = getCachedElement(statusId);
                if (statusEl) {
                    statusEl.textContent = label;
                    statusEl.style.fill = color;
                }
            }
        }

        // --- Utilization history area chart (canvas) ---
        function setupCanvasDPI(canvasId) {
            const canvas = getCachedElement(canvasId);
            if (!canvas) return null;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            const w = Math.round(rect.width);
            const h = Math.round(rect.height);
            if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvasContextCache.delete(canvasId);
            }
            let ctx = canvasContextCache.get(canvasId);
            if (!ctx) {
                ctx = canvas.getContext('2d');
                canvasContextCache.set(canvasId, ctx);
            }
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            return { ctx, w, h };
        }

        // drawAreaChart: maxValue defaults to 100 (percentage). Pass a higher value for auto-scaled charts.
        function drawAreaChart(canvasId, dataArray, colors, currentValue, valueElId, valueSuffix, maxValue) {
            if (!valueSuffix) valueSuffix = '%';
            if (!maxValue) maxValue = 100;
            const setup = setupCanvasDPI(canvasId);
            if (!setup) return;
            const { ctx, w, h } = setup;

            // Update the value overlay
            if (valueElId) {
                const valEl = getCachedElement(valueElId);
                if (valEl) valEl.textContent = currentValue + valueSuffix;
            }

            ctx.clearRect(0, 0, w, h);
            if (dataArray.length < 2) return;

            const n = dataArray.length;
            const padX = 0;
            const padTop = 24;
            const padBottom = 4;
            const chartH = h - padTop - padBottom;
            const stepX = (w - 2 * padX) / (60 - 1); // always 60-slot width
            const offsetX = (60 - n) * stepX; // right-align data

            // Build points
            const pts = [];
            for (let i = 0; i < n; i++) {
                const x = padX + offsetX + i * stepX;
                const y = padTop + chartH * (1 - Math.min(dataArray[i], maxValue) / maxValue);
                pts.push({ x, y });
            }

            // Monotone cubic interpolation (Fritsch-Carlson)
            const xs = pts.map(p => p.x);
            const ys = pts.map(p => p.y);
            const ms = monotoneCubicSlopes(xs, ys);

            // Draw filled area with gradient
            const gradient = ctx.createLinearGradient(0, padTop, 0, h);
            gradient.addColorStop(0, colors.top);
            gradient.addColorStop(1, colors.bottom);

            ctx.beginPath();
            ctx.moveTo(pts[0].x, h);
            ctx.lineTo(pts[0].x, pts[0].y);
            for (let i = 0; i < n - 1; i++) {
                const dx = xs[i + 1] - xs[i];
                const cx1 = xs[i] + dx / 3;
                const cy1 = ys[i] + ms[i] * dx / 3;
                const cx2 = xs[i + 1] - dx / 3;
                const cy2 = ys[i + 1] - ms[i + 1] * dx / 3;
                ctx.bezierCurveTo(cx1, cy1, cx2, cy2, xs[i + 1], ys[i + 1]);
            }
            ctx.lineTo(pts[n - 1].x, h);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Draw stroke line on top
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 0; i < n - 1; i++) {
                const dx = xs[i + 1] - xs[i];
                const cx1 = xs[i] + dx / 3;
                const cy1 = ys[i] + ms[i] * dx / 3;
                const cx2 = xs[i + 1] - dx / 3;
                const cy2 = ys[i + 1] - ms[i + 1] * dx / 3;
                ctx.bezierCurveTo(cx1, cy1, cx2, cy2, xs[i + 1], ys[i + 1]);
            }
            ctx.strokeStyle = colors.line;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function monotoneCubicSlopes(xs, ys) {
            const n = xs.length;
            const ds = [];
            const ms = [];
            for (let i = 0; i < n - 1; i++) {
                const dx = xs[i + 1] - xs[i];
                ds.push(dx === 0 ? 0 : (ys[i + 1] - ys[i]) / dx);
            }
            ms.push(ds[0] || 0);
            for (let i = 1; i < n - 1; i++) {
                if (ds[i - 1] * ds[i] <= 0) {
                    ms.push(0);
                } else {
                    ms.push((ds[i - 1] + ds[i]) / 2);
                }
            }
            ms.push(ds[n - 2] || 0);

            // Fritsch-Carlson monotonicity correction
            for (let i = 0; i < n - 1; i++) {
                if (ds[i] === 0) {
                    ms[i] = 0;
                    ms[i + 1] = 0;
                } else {
                    const alpha = ms[i] / ds[i];
                    const beta = ms[i + 1] / ds[i];
                    const s = alpha * alpha + beta * beta;
                    if (s > 9) {
                        const t = 3 / Math.sqrt(s);
                        ms[i] = t * alpha * ds[i];
                        ms[i + 1] = t * beta * ds[i];
                    }
                }
            }
            return ms;
        }

        // --- Circular clock speed gauge ---
        const CLOCK_ARC_LENGTH = 235.62; // 270° arc of circle r=50

        function updateClockGauge(fillId, textId, clockMhz, maxKey) {
            const fill = getCachedElement(fillId);
            const text = getCachedElement(textId);
            if (!fill || !text) return;

            // Auto-expand max tracker
            if (clockMhz * 1.1 > clockMaxTracker[maxKey]) {
                clockMaxTracker[maxKey] = clockMhz * 1.1;
            }

            const fraction = Math.max(0, Math.min(1, clockMhz / clockMaxTracker[maxKey]));
            const offset = CLOCK_ARC_LENGTH * (1 - fraction);
            fill.style.strokeDashoffset = offset;

            text.textContent = clockMhz;
        }

        // Clear canvas cache on resize
        window.addEventListener('resize', () => { canvasContextCache.clear(); });

        function initializeDashboard() {
            const dashboardHTML = `
                    <!-- GPU Card -->
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Graphics Card (GPU)</div>
                        </div>
                        <div class="chart-container">
                            <span class="chart-label">Utilization</span>
                            <span class="chart-value" id="gpu-util-value">--%</span>
                            <canvas id="gpu-util-chart"></canvas>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">VRAM Usage</span>
                            <span class="metric-value" id="gpu-vram-text">Loading...</span>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill gpu-fill" id="gpu-vram-bar"></div>
                        </div>
                        <div class="gauge-row">
                            <div class="gauge-container">
                                <svg class="half-gauge-svg" viewBox="0 0 140 85">
                                    <path class="half-gauge-bg" d="M 15 70 A 55 55 0 0 1 125 70" />
                                    <path class="half-gauge-fill" id="gpu-temp-gauge-fill" d="M 15 70 A 55 55 0 0 1 125 70"
                                          stroke-dasharray="${HALF_GAUGE_ARC_LENGTH}" stroke-dashoffset="${HALF_GAUGE_ARC_LENGTH}" />
                                    <text class="gauge-value-text" x="70" y="62" id="gpu-temp-gauge-text">--°C</text>
                                    <text class="gauge-label-text" x="70" y="80">Temperature</text>
                                </svg>
                            </div>
                            <div class="clock-gauge-container">
                                <svg class="clock-gauge-svg" viewBox="0 0 120 120">
                                    <defs>
                                        <linearGradient id="gpu-clock-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" stop-color="#ff6b6b"/>
                                            <stop offset="100%" stop-color="#ff8e53"/>
                                        </linearGradient>
                                    </defs>
                                    <circle class="clock-gauge-bg" cx="60" cy="60" r="50"
                                            stroke-dasharray="${CLOCK_ARC_LENGTH} 78.54"
                                            transform="rotate(135 60 60)" />
                                    <circle class="clock-gauge-fill" id="gpu-clock-gauge-fill" cx="60" cy="60" r="50"
                                            stroke="url(#gpu-clock-gradient)"
                                            stroke-dasharray="${CLOCK_ARC_LENGTH} 78.54"
                                            stroke-dashoffset="${CLOCK_ARC_LENGTH}"
                                            transform="rotate(135 60 60)" />
                                    <text class="clock-value-text" x="60" y="58" id="gpu-clock-gauge-text">--</text>
                                    <text class="clock-unit-text" x="60" y="72">MHz</text>
                                    <text class="clock-label-text" x="60" y="95">Core Clock</text>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <!-- CPU Card -->
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Processor (CPU)</div>
                        </div>
                        <div class="chart-container">
                            <span class="chart-label">Utilization</span>
                            <span class="chart-value" id="cpu-util-value">--%</span>
                            <canvas id="cpu-util-chart"></canvas>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Cores / Threads</span>
                            <span class="metric-value" id="cpu-cores">Loading...</span>
                        </div>
                        <div class="gauge-row">
                            <div class="gauge-container">
                                <svg class="half-gauge-svg" viewBox="0 0 140 85">
                                    <path class="half-gauge-bg" d="M 15 70 A 55 55 0 0 1 125 70" />
                                    <path class="half-gauge-fill" id="cpu-temp-gauge-fill" d="M 15 70 A 55 55 0 0 1 125 70"
                                          stroke-dasharray="${HALF_GAUGE_ARC_LENGTH}" stroke-dashoffset="${HALF_GAUGE_ARC_LENGTH}" />
                                    <text class="gauge-value-text" x="70" y="62" id="cpu-temp-gauge-text">--°C</text>
                                    <text class="gauge-label-text" x="70" y="80">Temperature</text>
                                </svg>
                            </div>
                            <div class="clock-gauge-container">
                                <svg class="clock-gauge-svg" viewBox="0 0 120 120">
                                    <defs>
                                        <linearGradient id="cpu-clock-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" stop-color="#4ecdc4"/>
                                            <stop offset="100%" stop-color="#44a08d"/>
                                        </linearGradient>
                                    </defs>
                                    <circle class="clock-gauge-bg" cx="60" cy="60" r="50"
                                            stroke-dasharray="${CLOCK_ARC_LENGTH} 78.54"
                                            transform="rotate(135 60 60)" />
                                    <circle class="clock-gauge-fill" id="cpu-clock-gauge-fill" cx="60" cy="60" r="50"
                                            stroke="url(#cpu-clock-gradient)"
                                            stroke-dasharray="${CLOCK_ARC_LENGTH} 78.54"
                                            stroke-dashoffset="${CLOCK_ARC_LENGTH}"
                                            transform="rotate(135 60 60)" />
                                    <text class="clock-value-text" x="60" y="58" id="cpu-clock-gauge-text">--</text>
                                    <text class="clock-unit-text" x="60" y="72">MHz</text>
                                    <text class="clock-label-text" x="60" y="95">Clock Speed</text>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <!-- RAM Card -->
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Memory (RAM)</div>
                        </div>
                        <div class="chart-container">
                            <span class="chart-label">Utilization</span>
                            <span class="chart-value" id="ram-util-value">--%</span>
                            <canvas id="ram-util-chart"></canvas>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Usage</span>
                            <span class="metric-value" id="ram-usage">Loading...</span>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill ram-fill" id="ram-usage-bar"></div>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Speed</span>
                            <span class="metric-value" id="ram-speed">Loading...</span>
                        </div>
                    </div>

                    <!-- Storage Card -->
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Storage Performance</div>
                        </div>
                        <div class="chart-container">
                            <span class="chart-label">Sequential Read</span>
                            <span class="chart-value" id="storage-read-value">-- MB/s</span>
                            <canvas id="storage-read-chart"></canvas>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Random Read (4K)</span>
                            <span class="metric-value" id="storage-read-iops">Loading...</span>
                        </div>
                        <div class="chart-container">
                            <span class="chart-label">Sequential Write</span>
                            <span class="chart-value" id="storage-write-value">-- MB/s</span>
                            <canvas id="storage-write-chart"></canvas>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Random Write (4K)</span>
                            <span class="metric-value" id="storage-write-iops">Loading...</span>
                        </div>
                    </div>

                    <!-- Power & Thermal Card -->
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Power & Thermal Management</div>
                        </div>
                        <div class="chart-container">
                            <span class="chart-label">System Power</span>
                            <span class="chart-value" id="power-usage-value">-- W</span>
                            <canvas id="power-usage-chart"></canvas>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">PSU Efficiency</span>
                            <span class="metric-value"><span id="power-efficiency">--</span>% <span class="performance-indicator excellent">80+ Gold</span></span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">CPU Power</span>
                            <span class="metric-value" id="power-cpu">Loading...</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">GPU Power</span>
                            <span class="metric-value" id="power-gpu">Loading...</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Case Temperature</span>
                            <span class="metric-value" id="case-temp">Loading...</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Fan Speeds</span>
                            <span class="metric-value" id="fan-speeds">Loading...</span>
                        </div>
                    </div>
                `;
                document.getElementById('dashboard').innerHTML = dashboardHTML;
                elementCache.clear(); // Invalidate cached refs after DOM rebuild
                canvasContextCache.clear();
                isInitialized = true;
        }

        async function updateMetrics() {
            try {
                const response = await fetch('/api/metrics');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                
                // Update connection status
                if (!isConnected) {
                    isConnected = true;
                    document.querySelector('.status-dot').style.background = '#00ff88';
                }

                // Initialize dashboard HTML if first time
                if (!isInitialized) {
                    initializeDashboard();
                    return; // Skip update on first load, let initialization settle
                }

                // Push utilization history and update clock max trackers
                pushHistory(utilizationHistory.gpu, data.gpu.utilization_percent);
                pushHistory(utilizationHistory.cpu, data.cpu.utilization_percent);
                pushHistory(utilizationHistory.ram, data.ram.utilization_percent);
                pushHistory(storageHistory.read, data.storage.seq_read_mbps);
                pushHistory(storageHistory.write, data.storage.seq_write_mbps);
                pushHistory(powerHistory, data.power.system_power_w);

                // Auto-scale storage and power chart maxes
                if (data.storage.seq_read_mbps * 1.2 > chartMaxTracker.storageRead) {
                    chartMaxTracker.storageRead = Math.round(data.storage.seq_read_mbps * 1.2);
                }
                if (data.storage.seq_write_mbps * 1.2 > chartMaxTracker.storageWrite) {
                    chartMaxTracker.storageWrite = Math.round(data.storage.seq_write_mbps * 1.2);
                }
                if (data.power.system_power_w * 1.2 > chartMaxTracker.power) {
                    chartMaxTracker.power = Math.round(data.power.system_power_w * 1.2);
                }

                if (data.gpu.core_clock_mhz * 1.1 > clockMaxTracker.gpu) {
                    clockMaxTracker.gpu = Math.round(data.gpu.core_clock_mhz * 1.1);
                }
                if (data.cpu.current_clock_mhz * 1.1 > clockMaxTracker.cpu) {
                    clockMaxTracker.cpu = Math.round(data.cpu.current_clock_mhz * 1.1);
                }

                // Batch all DOM mutations into a single repaint
                requestAnimationFrame(() => {
                    // Calculate percentages
                    const vramPercent = (data.gpu.vram_used_mb / data.gpu.vram_total_mb * 100).toFixed(1);
                    const ramPercent = data.ram.utilization_percent.toFixed(1);

                    // --- GPU card ---
                    drawAreaChart('gpu-util-chart', utilizationHistory.gpu, chartColors.gpu, data.gpu.utilization_percent, 'gpu-util-value');
                    updateElement('gpu-vram-text', `${data.gpu.vram_used_mb} / ${data.gpu.vram_total_mb} MB (${vramPercent}%)`);
                    updateBar('gpu-vram-bar', vramPercent);
                    updateHalfGauge('gpu-temp-gauge-fill', 'gpu-temp-gauge-text', data.gpu.temperature_c, 30, 100);
                    updateClockGauge('gpu-clock-gauge-fill', 'gpu-clock-gauge-text', data.gpu.core_clock_mhz, 'gpu');

                    // --- CPU card ---
                    drawAreaChart('cpu-util-chart', utilizationHistory.cpu, chartColors.cpu, data.cpu.utilization_percent, 'cpu-util-value');
                    updateElement('cpu-cores', `${data.cpu.core_count} / ${data.cpu.thread_count}`);
                    updateHalfGauge('cpu-temp-gauge-fill', 'cpu-temp-gauge-text', data.cpu.temperature_c, 30, 100);
                    updateClockGauge('cpu-clock-gauge-fill', 'cpu-clock-gauge-text', data.cpu.current_clock_mhz, 'cpu');

                    // --- RAM card ---
                    drawAreaChart('ram-util-chart', utilizationHistory.ram, chartColors.ram, data.ram.utilization_percent, 'ram-util-value');
                    updateElement('ram-usage', `${formatBytes(data.ram.used_mb)} / ${formatBytes(data.ram.total_mb)} (${ramPercent}%)`);
                    updateBar('ram-usage-bar', ramPercent);
                    updateElement('ram-speed', `DDR-${data.ram.speed_mhz}`);

                    // --- Storage card ---
                    drawAreaChart('storage-read-chart', storageHistory.read, chartColors.storageRead, data.storage.seq_read_mbps, 'storage-read-value', ' MB/s', chartMaxTracker.storageRead);
                    drawAreaChart('storage-write-chart', storageHistory.write, chartColors.storageWrite, data.storage.seq_write_mbps, 'storage-write-value', ' MB/s', chartMaxTracker.storageWrite);
                    updateElement('storage-read-iops', `${(data.storage.random_read_iops / 1000).toFixed(0)}K IOPS`);
                    updateElement('storage-write-iops', `${(data.storage.random_write_iops / 1000).toFixed(0)}K IOPS`);

                    // --- Power & Thermal card ---
                    drawAreaChart('power-usage-chart', powerHistory, chartColors.power, data.power.system_power_w, 'power-usage-value', 'W', chartMaxTracker.power);
                    updateElement('power-efficiency', data.power.efficiency_percent);
                    updateElement('power-cpu', `${data.power.cpu_power_w}W`);
                    updateElement('power-gpu', `${data.power.gpu_power_w}W`);
                    updateElement('case-temp', `${data.thermal.case_temp_c}°C`);

                    if (data.thermal.fan_speeds_rpm && data.thermal.fan_speeds_rpm.length > 0) {
                        updateElement('fan-speeds', `${data.thermal.fan_speeds_rpm.slice(0, 3).join(' / ')} RPM`);
                    }

                    updateElement('lastUpdate', `Last updated: ${new Date().toLocaleTimeString()}`);
                });

            } catch (error) {
                console.error('Error fetching metrics:', error);
                if (isConnected) {
                    isConnected = false;
                    document.querySelector('.status-dot').style.background = '#f44336';
                    document.getElementById('dashboard').innerHTML = `
                        <div class="error">
                            ❌ Connection lost to monitoring service<br>
                            <small>Error: ${error.message}</small>
                        </div>
                    `;
                    document.getElementById('lastUpdate').textContent = `Connection lost at ${new Date().toLocaleTimeString()}`;
                    elementCache.clear();
                    canvasContextCache.clear();
                    isInitialized = false;
                }
            }
        }

        // Recursive setTimeout — schedules next poll only after current one completes
        let pollTimeoutId = null;

        function schedulePoll() {
            pollTimeoutId = setTimeout(async () => {
                await updateMetrics();
                schedulePoll();
            }, 1000);
        }

        // Pause polling when the window is hidden/minimized, resume when visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (pollTimeoutId !== null) {
                    clearTimeout(pollTimeoutId);
                    pollTimeoutId = null;
                }
            } else {
                if (pollTimeoutId === null) {
                    updateMetrics();
                    schedulePoll();
                }
            }
        });

        // Initial load + start polling
        updateMetrics();
        schedulePoll();
    </script>
</body>
</html>
